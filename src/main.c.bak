#include <setjmp.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>

typedef struct thread_t {
  sigjmp_buf env;
  size_t id;
  bool started;
  bool finished;
} thread_t;

void scheduler(void);
void do_thread(sigjmp_buf *scheduler_env, thread_t *thread);
bool every_thread_is_finished(thread_t *threads[], size_t n_threads);

bool every_thread_is_finished(thread_t *threads[], size_t n_threads) {
  for (size_t i = 0; i < n_threads; ++i) {
    if (!threads[i]->finished) {
      return false;
    }
  }
  return true;
}

void scheduler(void) {
  sigjmp_buf *env = malloc(sizeof(thread_t));
  size_t n_threads = 2;
  thread_t *threads[2];
  for (size_t i = 0; i < n_threads; ++i) {
    threads[i] = malloc(sizeof(thread_t));
    threads[i]->started = false;
    threads[i]->finished = false;
    threads[i]->id = i + 1;
  }
  // Save current environment
  int last_thread = sigsetjmp(*env, false);
  // Select next thread. This example uses round robin.
  printf("last_thread = %d\n", last_thread);
  printf("last_thread %% n_threads = %lu\n", last_thread % n_threads);
  thread_t *next_thread = threads[(last_thread % n_threads)];
  printf("{ .id = %zu, .started = %d, .finished = %d }\n", next_thread->id,
         next_thread->started, next_thread->finished);
  if (!next_thread->finished) {
    if (!next_thread->started) {
      do_thread(env, next_thread);
    } else {
      siglongjmp(next_thread->env, true);
    }
  } else if (every_thread_is_finished(threads, n_threads)) {
    exit(EXIT_SUCCESS);
  } else {
    siglongjmp(*env, next_thread->id);
  }
}

void do_thread(sigjmp_buf *scheduler_env, thread_t *thread) {
  thread->started = true;
  printf("Thread %zu has been given processor time...\n", thread->id);
  if (sigsetjmp(thread->env, false) == 0) {
    printf("Returning processor time to scheduler...\n");
    siglongjmp(*scheduler_env, thread->id);
  }
  printf("Thread %zu continuing with work...\n", thread->id);
  // Finalize thread work.
  thread->finished = true;
  printf("Thread %zu finished, returning processor time to scheduler...\n",
         thread->id);
  siglongjmp(*scheduler_env, thread->id);
}

int main(void) {
  scheduler();
  return EXIT_SUCCESS;
}
